<!DOCTYPE html>
<html lang="en">
	<head>
		<title>SpaceX StarShip</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link rel="icon" href="./favicon.ico" type="image/x-icon"/>
		<link rel="shortcut icon" href="./favicon.ico" type="image/x-icon"/>
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>
		<div id="canvas">
			<div id="options">
				<center>
				<br>
				StarShip Simulator by Elric / Anaconda<br>
				<h1><b>---=== Options ===---</b></h1>
				<button id="buttonLowPoly" class="myButton">Low Poly version</button><br>
				<br>
				<button id="buttonHighPoly" class="myButton">High Poly version</button><br>
				<br>
				<div id="sfcxdk9e7e626k4t67ey5afp5zgm8ukty5p"></div>
				<script type="text/javascript" src="https://counter8.stat.ovh/private/counter.js?c=xdk9e7e626k4t67ey5afp5zgm8ukty5p&down=async" async></script>
				</center>
				<br>
			</div>
		
			<div id="help">
				<center>
				<br>
				<button id="buttonCloseHelp1" class="myButton">Press here to close</button><br>
				<h1><b>---=== Help ===---</b></h1>
				</center>
				<p>
					<h3><b>&nbsp;In non VR:</b></h3>
					<ul>
						<li>H - Toggle this Help screen visibility.</li>
						<li>Use Mouse to control camera position.</li>
						<li>R - Reset Wings rotation.</li>
						<li>r - Reset Last Wing rotation.</li>
						<li>M - Wing rotation increased.</li>
						<li>m - Wing rotation decreased.</li>
						<li>1 - Move Top-Left wing (use CTRL to decrease).</li>
						<li>2 - Move Top-Right wing (use CTRL to decrease).</li>
						<li>3 - Move Bottom-Left wing (use CTRL to decrease).</li>
						<li>4 - Move Bottom-Right wing (use CTRL to decrease).</li>
						<li>5 - Move Top wings together (use CTRL to decrease).</li>
						<li>6 - Move Bottom wings together (use CTRL to decrease).</li>
						<li>7 - Move 4 wings together (use CTRL to decrease).</li>
						<li>8 - Wings folded at medium.</li>
						<li>9 - Wings folded at maximum.</li>
						<li>0 - Open all Wings.</li>
						<li>C - StarShip reset to launch position.</li>
						<li>c - StarShip reset to land position.</li>
						<li>Arrow Up - StarShip Up.</li>
						<li>Arrow Down - StarShip Down.</li>
						<li>Arrow Left - StarShip Rotate Left.</li>
						<li>Arrow Right - StarShip Rotate Right.</li>						
						<li>CTRL + Arrow Up - StarShip Move Forward.</li>
						<li>CTRL + Arrow Down - StarShip Move Backward.</li>
						<li>CTRL + Arrow Left - StarShip Move Left.</li>
						<li>CTRL + Arrow Right - StarShip Move Right.</li>						
						<li>G - StarShip on space environment.</li>
						<li>g - StarShip on ground.</li>
						<li>O - Shadows on.</li>
						<li>o - Shadows off.</li>
						<li>E - Toggle VR statistics visibility.</li>
						<li>e - Toggle statistics visibility.</li>
						<li>F - StarShip fire engines.</li>
						<li>f - StarShip shutdown engines.</li>
						<li>CTRL + F1 - Toggle Engine 1 on/off.</li>
						<li>CTRL + F2 - Toggle Engine 2 on/off.</li>
						<li>CTRL + F3 - Toggle Engine 3 on/off.</li>
						<li>S - Reset Engines rotation.</li>
						<li>s - Reset Last Engine rotation.</li>						
						<li>NUMPAD 1 - Rotate Engine 1 X Axis (use CTRL to reverse).</li>
						<li>NUMPAD 2 - Reset Rotation Engine 1.</li>
						<li>NUMPAD 3 - Rotate Engine 1 Y Axis (use CTRL to reverse).</li>
						<li>NUMPAD 4 - Rotate Engine 2 X Axis (use CTRL to reverse).</li>
						<li>NUMPAD 5 - Reset Rotation Engine 2.</li>
						<li>NUMPAD 6 - Rotate Engine 2 Y Axis (use CTRL to reverse).</li>
						<li>NUMPAD 7 - Rotate Engine 3 X Axis (use CTRL to reverse).</li>
						<li>NUMPAD 8 - Reset Rotation Engine 3.</li>
						<li>NUMPAD 9 - Rotate Engine 3 Y Axis (use CTRL to reverse).</li>						
						<li>V - Restore to default camera.</li>
						<li>v - Cycle fixed cameras.</li>						
					</ul>
					<h3><b>&nbsp;In VR:</b></h3>
					<ul>						
						<li>Use the controller panels to manage StarShip actions.</li>
						<li>Use Trigger - to teletransport to another position.</li>
						<li>Use Grip - to grab StarShip parts.</li>
						<li>Use a controller gamepad - to move arround.</li>
						<li>Use a keyboard to execute non VR key commands.</li>
					</ul>
					<h3><b>&nbsp;Developer:</b></h3>
					<ul>						
						<li>i - Output renderer information.</li>
						<li>J - Hide reference objects.</li>
						<li>j - Show reference objects.</li>
						<li>D - Hide dragon.</li>
						<li>d - Show dragon.</li>
					</ul>
				</p>
				<br>
				<center>
				StarShip Simulator by Elric / Anaconda<br>
				<button id="buttonCloseHelp2" class="myButton">Press here to close</button><br>
				</center>
				<br>
			</div>
		</div>
	
		<section id="loading-screen">
			<center>
			<img id="imgLogo" src="./spacex.png"/>
			<br>
			StarShip Simulator by Elric / Anaconda<br>
			Progress: <label id="lblProgressValue">Waiting...</label><br>
			<progress id="pbProgressBar" max="100" value="0"/><br>
			</center>
			<div id="loader"/>
		</section>
							
		<script src="./tweenmax/TweenMax.min.js"></script>
		
		<script src="./env.js"></script> 
		
		<script type="module">				
			// Constants
			const SHADOW_MAP_WIDTH = 1024, SHADOW_MAP_HEIGHT = 1024;
		
			// Imports
			import * as THREE from './three.js/three.js-master/build/three.module.js';			
			import Stats from './three.js/three.js-master/examples/jsm/libs/stats.module.js';
			import StatsVR from './statsvr/statsvr.js'
			import { MapControls } from './three.js/three.js-master/examples/jsm/controls/OrbitControls.js';
			import { OrbitControls } from './three.js/three.js-master/examples/jsm/controls/OrbitControls.js';
			import { FirstPersonControls } from './three.js/three.js-master/examples/jsm/controls/FirstPersonControls.js';
			import { FlyControls } from './three.js/three.js-master/examples/jsm/controls/FlyControls.js';
			import { FBXLoader } from './three.js/three.js-master/examples/jsm/loaders/FBXLoader.js';
			import { GLTFLoader } from './three.js/three.js-master/examples/jsm/loaders/GLTFLoader.js';
			import { DRACOLoader } from './three.js/three.js-master/examples/jsm/loaders/DRACOLoader.js';
			import { RoughnessMipmapper } from './three.js/three.js-master/examples/jsm/utils/RoughnessMipmapper.js';
			import { ShadowMapViewer } from './three.js/three.js-master/examples/jsm/utils/ShadowMapViewer.js';
			import { Lensflare, LensflareElement } from './three.js/three.js-master/examples/jsm/objects/Lensflare.js'
			import { VRButton } from './three.js/three.js-master/examples/jsm/webxr/VRButton.js'
			import { XRControllerModelFactory } from './three.js/three.js-master/examples/jsm/webxr/XRControllerModelFactory.js';
			import ParticleSystem from './particleSystem/particleSystem.js'

			// Variables
			let container;
			let scene, renderer;
			let currentCamera = null;
			let camera, cameraHolder;
			let controls;
			let stats = null;
			let statsVisibility;
			let statsVR = null;
			let statsVRVisibility;
			let sunLight, spaceLight, dirLight;
			let windowHalfX, windowHalfY;
			
			let starshipModelFilename = "StarShip-SN8.glb";
			
			let plane;
			let material, envMap;
			let textureCube, textureCube2;
						
			const clock = new THREE.Clock();
			
			let SCREEN_WIDTH = window.innerWidth;
			let SCREEN_HEIGHT = window.innerHeight;			
			let lightShadowMapViewer;
			
			let DragonMesh;
			let HumanMesh;
			let CubeMesh;
			
			let objStarShip;
			let objTopLeftWing;
			let objTopRightWing;
			let objBottomLeftWing;
			let objBottomRightWing;
			
			const incrementWingRotation = 0.01;		
			let lastWingRotated;
			let multiplierWingRotation = 1;
			
			let textureLensFlare0, textureLensFlare2, textureLensFlare3;
			let lensflare;
			
			let controller1, controller2;
			let controllerGrip1, controllerGrip2;
			
			let raycaster;
			const intersected = [];
			const tempMatrix = new THREE.Matrix4();
			const intersectableObjects = [];
			let intersectionParent;
			
			const lineSegments = 10;
			let lineGeometryVertices;
			const g = new THREE.Vector3(0,-9.8,0);
			const tempVec = new THREE.Vector3();
			const tempVec1 = new THREE.Vector3();
			const tempVecP = new THREE.Vector3();
			const tempVecV = new THREE.Vector3();			
			let guidingController = null;
			let guideline, guidelight, guidesprite;
			
			let objMotor1, objMotor2, objMotor3;
			let particlesE1, particlesE2, particlesE3;
			let particlesELight;
			let defaultEngineRotation1, defaultEngineRotation2, defaultEngineRotation3;
			const incrementEngineRotation = 0.005;					
			let lastEngineRotated;
			let lastEngineRotatedAxis;
			let lastEngineRotatedDefaultRotation; 
			
			const camerasFixedArray = [];
			let cameraFixedIndex = 0;

			let mouseRaycaster = new THREE.Raycaster();
			let mouseRaycasterCheck = false;
			const mouseIntersectableObjects = [];
			
			// Members			
			function main()
			{
				var btnLP = document.getElementById('buttonLowPoly');
				var btnHP = document.getElementById('buttonHighPoly');
				btnLP.onclick = function(){ selectOptionLowPoly(); }
				btnHP.onclick = function(){ selectOptionHighPoly(); }
				
				var help1 = document.getElementById('buttonCloseHelp1');
				var help2 = document.getElementById('buttonCloseHelp2');
				help1.onclick = function(){ closeHelpScreen(); }				
				help2.onclick = function(){ closeHelpScreen(); }				
			
				closeHelpScreen();				
				closeLoadingScreen();
				showOptionsScreen();
			}
			
			function showLoadingScreen()
			{
				const loadingScreen = document.getElementById( 'loading-screen' );
				loadingScreen.style.visibility = "visible";
			}		
			function closeLoadingScreen()
			{
				const loadingScreen = document.getElementById( 'loading-screen' );
				loadingScreen.style.visibility = "hidden";
			}
			
			function showOptionsScreen()
			{
				const optionsScreen = document.getElementById( 'options' );
				optionsScreen.style.visibility = "visible";
			}
			function closeOptionsScreen()
			{
				const optionsScreen = document.getElementById( 'options' );
				optionsScreen.style.visibility = "hidden";
			}
			
			function showHelpScreen()
			{
				const helpScreen = document.getElementById( 'help' );
				helpScreen.style.visibility = "visible";
			}		
			function closeHelpScreen()
			{
				const helpScreen = document.getElementById( 'help' );
				helpScreen.style.visibility = "hidden";
			}		

			function selectOptionLowPoly()
			{
				showLoadingScreen();
				closeOptionsScreen();
				starshipModelFilename = "StarShip-SN8-LowPoly.glb";
				init();
			}			
			function selectOptionHighPoly()
			{
				showLoadingScreen();
				closeOptionsScreen();
				starshipModelFilename = "StarShip-SN8.glb";
				init();
			}
			
			function init()
			{
				init3D();
				animate();
			}
			
			function init3D() {
				// Web Document
				container = document.getElementById( 'canvas' );

				// Loading screen
				const loadingManager = new THREE.LoadingManager( () => {				
					const loadingScreen = document.getElementById( 'loading-screen' );
					loadingScreen.classList.add( 'fade-out' );					
					loadingScreen.addEventListener( 'transitionstart', onTransitionStart );					
					loadingScreen.addEventListener( 'transitionend', onTransitionEnd );					
				} );							
				loadingManager.onProgress = function ( url, itemsLoaded, itemsTotal ) {
					debugLog( 'Loading file: ' + url + '.\nLoaded ' + itemsLoaded + ' of ' + itemsTotal + ' files.' );
					document.getElementById('lblProgressValue').innerHTML = itemsLoaded + ' of ' + itemsTotal;
					document.getElementById('pbProgressBar').max = itemsTotal;
					document.getElementById('pbProgressBar').value = itemsLoaded;
				};

				// Camera
				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 2500 );
				camera.position.set( 50, 60, 50 );
				
				// Scene
				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xd4cec0 );
				scene.fog = new THREE.Fog( 0xd4cec0, 50, 500 );

				// Camera Group
				cameraHolder = new THREE.Group();
				cameraHolder.add(camera);
				cameraHolder.position.set(-14, 0, +2);
				cameraHolder.rotation.set(0, THREE.MathUtils.degToRad(260), 0);
				scene.add(cameraHolder); 

				// Lights				
				sunLight = new THREE.HemisphereLight( 0xbfbfbf, 0xd4cec0 )
				scene.add( sunLight );
				spaceLight = new THREE.HemisphereLight( 0x5f5f7f, 0x0f0f1f )
				spaceLight.visible = false;
				scene.add( spaceLight );
				
				dirLight = new THREE.DirectionalLight( 0xd4cec0 );				
				dirLight.position.set( -100, 70, 50 );				
				dirLight.castShadow = true;
				dirLight.shadow.camera.near = 10;
				dirLight.shadow.camera.far = 250;
				dirLight.shadow.camera.left = -50;
				dirLight.shadow.camera.bottom = -50;
				dirLight.shadow.camera.right = 50;
				dirLight.shadow.camera.top = 50;
				dirLight.shadow.bias = 0.0001;
				dirLight.shadow.mapSize.width = SHADOW_MAP_WIDTH;
				dirLight.shadow.mapSize.height = SHADOW_MAP_HEIGHT;
				scene.add( dirLight );
								
				if (_debugShadow)
				{
					const helper = new THREE.CameraHelper( dirLight.shadow.camera );
					scene.add( helper );
								
					lightShadowMapViewer = new ShadowMapViewer( dirLight );
					lightShadowMapViewer.position.x = 10;
					lightShadowMapViewer.position.y = SCREEN_HEIGHT - ( SHADOW_MAP_HEIGHT / 6 ) - 10;
					lightShadowMapViewer.size.width = SHADOW_MAP_WIDTH / 6;
					lightShadowMapViewer.size.height = SHADOW_MAP_HEIGHT / 6;
					lightShadowMapViewer.update();
				}
				
				const loaderTexture = new THREE.TextureLoader(loadingManager);
				
				// Lensflare
				textureLensFlare0 = loaderTexture.load( './models/lensflare/lensflare0.png' ),
				textureLensFlare2 = loaderTexture.load( './models/lensflare/hexangle.png' ),
				textureLensFlare3 = loaderTexture.load( './models/lensflare/lensflare3.png' ),
				lensflare = new Lensflare();
				lensflare.position.copy( dirLight.position );
				lensflare.addElement( new LensflareElement( textureLensFlare0, 350, 0.0 ));
				lensflare.addElement( new LensflareElement( textureLensFlare3,  60, 0.6 ));
				lensflare.addElement( new LensflareElement( textureLensFlare2,  70, 0.7 ));
				lensflare.addElement( new LensflareElement( textureLensFlare3, 120, 0.9 ));
				lensflare.addElement( new LensflareElement( textureLensFlare3,  80, 1.0 ));
				scene.add( lensflare );
				
				// Ground
				plane = new THREE.Mesh(
					new THREE.PlaneBufferGeometry( 250, 250, 32, 32 ),
					new THREE.MeshStandardMaterial( {
						map: loaderTexture.load('./models/background/ny.png'),						
					} )
				);
				plane.rotation.x = - Math.PI / 2;
				plane.receiveShadow = true;
				scene.add( plane );								
				
				if (_debugDimensionGrids)
				{
					// Ruler Ground
					const grid = new THREE.GridHelper( 100, 100, 0x000000, 0x000000 );
					grid.material.opacity = 0.2;
					grid.material.transparent = true;
					scene.add( grid );
					
					// Ruler Vertical
					const grid2 = new THREE.GridHelper( 50, 50, 0x000000, 0x000000 );
					grid2.position.y = 25;
					grid2.position.z = -10;
					grid2.rotation.x = - Math.PI / 2;
					grid2.material.opacity = 0.4;
					grid2.material.transparent = true;
					scene.add( grid2 );					
				}
								
				if (_debugCubeReference)
				{
					// Cube reference 1m				
					const geometry = new THREE.BoxGeometry( 1, 1, 1 );
					const cube = new THREE.Mesh( geometry, 
						new THREE.MeshStandardMaterial( {
							map: loaderTexture.load('./models/uv_grid_opengl.jpg')
						} ) );
					cube.position.set( -11.5, 0.5, -0.5 );
					cube.castShadow = true;
					cube.receiveShadow = false;
					CubeMesh = cube;
					scene.add( cube );
				}
				
				// Background
				const loaderSceneBackground = new THREE.CubeTextureLoader(loadingManager);
				loaderSceneBackground.setPath( './models/background/' );
				textureCube = loaderSceneBackground.load( [ 'px.jpg', 'nx.jpg', 'py.jpg', 'ny.jpg', 'pz.jpg', 'nz.jpg' ] );
				textureCube.encoding = THREE.sRGBEncoding;
				scene.background = textureCube;

				// Background2
				loaderSceneBackground.setPath( './models/background2/' );
				textureCube2 = loaderSceneBackground.load( [ 'px.jpg', 'nx.jpg', 'py.jpg', 'ny.jpg', 'pz.jpg', 'nz.jpg' ] );
				textureCube2.encoding = THREE.sRGBEncoding;				
				
				// Renderer
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.outputEncoding = THREE.sRGBEncoding;
				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				renderer.toneMappingExposure = 1;
				renderer.autoClear = false;
				renderer.shadowMap.enabled = true;
				renderer.xr.enabled = true;
				container.appendChild( renderer.domElement );
				
				// Load StarShip material						
				THREE.DefaultLoadingManager.onLoad = function ( ) {
					pmremGenerator.dispose();
				};
								
				var texture = loaderTexture.load("./models/MetallicMap.png", function(tx) {
					tx.anisotropy = 16;
					tx.magFilter = THREE.LinearFilter;
					tx.minFilter = THREE.LinearMipmapLinearFilter;
					tx.wrapS = THREE.RepeatWrapping;
					tx.wrapT = THREE.RepeatWrapping;
					tx.generateMipmaps = true;
				});

				material = new THREE.MeshStandardMaterial({
					map: texture,
					roughness: 0.15,
					metalness: 1.15,
					metalnessMap : texture,
					roughnessMap : texture,
					vertexTangents : true,
					envMapIntensity: 0.45,
					fog: true,
					side: THREE.FrontSide,
				});
  				
				loaderTexture.load( './models/MetallicEnv.jpg', function ( texture ) {
					texture.encoding = THREE.sRGBEncoding;
					envMap = pmremGenerator.fromEquirectangular( texture );
					texture.dispose();					
					applyEnvironmentMapToStarShip(envMap.texture, -1);
				} );	

				// Loaders FBX / GLTF
				const loaderFBX = new FBXLoader(loadingManager);
				const loaderGLTF = new GLTFLoader(loadingManager);
				const dracoLoader = new DRACOLoader(loadingManager);
				dracoLoader.setDecoderPath( './three.js/three.js-master/examples/js/libs/draco/gltf/' );
				loaderGLTF.setDRACOLoader( dracoLoader );
				
				// Load StarShip mesh 								
				loaderGLTF.setPath( './models/' );																	
				loaderGLTF.load(
					starshipModelFilename, 
					// called when the resource is loaded
					function ( gltf ) {
						var object = gltf.scene;													
						debugLog( 'StarShip objects: ' );
						object.traverse(function(child) {
								if (child instanceof THREE.Mesh) {
									debugLog( '- ' + child.name );
									
									child.castShadow = true;
									child.receiveShadow = true;
									child.material = material.clone();
									
									// get StarShip special objects
									switch (child.name)
									{
										case "101_Left_canard":
											objTopLeftWing = child;
											adaptWingObject(child);
											break;
										case "111_Right_canard":
											objTopRightWing = child;
											adaptWingObject(child);
											break;
										case "121_Left_Aft_Wing":
											objBottomLeftWing = child;
											adaptWingObject(child);
											break;
										case "131_Right_Aft_Wing":
											objBottomRightWing = child;
											adaptWingObject(child);
											break;
										case "7_Raptor_Engine001":
											objMotor1 = child;
											break;
										case "7_Raptor_Engine002":
											objMotor2 = child;
											break;
										case "7_Raptor_Engine003":
											objMotor3 = child;
											break;
									}									
									
									intersectableObjects.push(child);
								} 
								else if (child instanceof THREE.PerspectiveCamera)
								{
									debugLog( '-- Camera found ' + child.name );
									debugLog( '-- Camera Fov: ' + child.fov );
									debugLog( '-- Camera Aspect: ' + child.aspect );
									debugLog( '-- Camera Zoom: ' + child.zoom );
									debugLog( '-- Camera Near: ' + child.near );
									debugLog( '-- Camera Far: ' + child.far );
									debugLog( '-- Camera Rotation: ' + rotation2String(child.rotation) );
																						
									camerasFixedArray.push(child);									
									
									if (_debugFixedCameras)
									{
										const helper = new THREE.CameraHelper( child );
										scene.add( helper );
									}																		
								}
							});									
						objStarShip = object;
						if (envMap!=null)
							applyEnvironmentMapToStarShip(envMap.texture, -1);
						scene.add( object );												
						
						// Particles	
						generateEnginesParticleSystem(object);
						
						if (_enginesOffInitially)
						{
							particlesE1.setAddParticles(false);
							particlesE2.setAddParticles(false);
							particlesE3.setAddParticles(false);
							particlesELight.intensity = 0;
						}
					},
					// called as loading progresses
					function ( xhr ) {
						debugLog( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
					},
					// called when loading has errors
					function ( error ) {
						console.log( 'An error happened ' + error );
					}				
				);
					
				if (_debugHumanReference)
				{
					// Load Human reference
					loaderFBX.load(
						'./models/BaseHuman.fbx', 
						// called when the resource is loaded
						function ( object ) {
							object.traverse(function(child) {
									if (child instanceof THREE.Mesh) {
										child.castShadow = true;
										child.receiveShadow = false;
										child.position.x = -10.5;
										child.position.z = -0.5;
									}
								});		
							HumanMesh = object;
							scene.add( object );														
						},
						// called as loading progresses
						function ( xhr ) {
							debugLog( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
						},
						// called when loading has errors
						function ( error ) {
							console.log( 'An error happened ' + error );
						}				
					);				
				}

				if (_debugDragonReference)
				{
					// Load Dragon reference
					const roughnessMipmapper = new RoughnessMipmapper( renderer );
					loaderGLTF.setPath( './models/dragon/' );									
					loaderGLTF.load(
						'scene.gltf', 
						// called when the resource is loaded
						function ( gltf ) {
							gltf.scene.traverse(function(child) {
									if (child instanceof THREE.Mesh) {
										child.castShadow = true;
										child.receiveShadow = false;
										child.position.x = -10.5;
										child.position.y = -10.5;
										child.position.z = 5;
									}
								});				
							DragonMesh = gltf.scene;
							scene.add( gltf.scene );							
							roughnessMipmapper.dispose();
						},
						// called as loading progresses
						function ( xhr ) {
							debugLog( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
						},
						// called when loading has errors
						function ( error ) {
							console.log( 'An error happened ' + error );
						}				
					);				
				}				
				
				// Load controller panel
				loaderFBX.load(
					'./models/Controller.fbx', 
					// called when the resource is loaded
					function ( object ) {
						debugLog( 'Controller Panel objects: ' );
						object.traverse(function(child) {
								if (child instanceof THREE.Mesh) {
									debugLog( '- ' + child.name );
									
									child.castShadow = true;
									child.receiveShadow = false;
									
									if (child.name.includes("Button"))
									{
										debugLog( '- Button command found' );
										mouseIntersectableObjects.push(child);
									}
								}
							});		
						var controllerPanels = new THREE.Group();
						controllerPanels.position.set(-10, 0, 2);
						controllerPanels.scale.set(0.1, 0.1, 0.1);
						controllerPanels.add(object);
						scene.add( controllerPanels );						
					},
					// called as loading progresses
					function ( xhr ) {
						debugLog( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
					},
					// called when loading has errors
					function ( error ) {
						console.log( 'An error happened ' + error );
					}				
				);								
									
				// VR controllers
				controller1 = renderer.xr.getController( 0 );
				controller1.addEventListener( 'squeezestart', onGrabStart );
				controller1.addEventListener( 'squeezeend', onGrabEnd );
				controller1.addEventListener( 'selectstart', onTeletransportLocomotionStart );
				controller1.addEventListener( 'selectend', onTeletransportLocomotionEnd );
				cameraHolder.add( controller1 );
				
				controller2 = renderer.xr.getController( 1 );
				controller2.addEventListener( 'squeezestart', onGrabStart );
				controller2.addEventListener( 'squeezeend', onGrabEnd );
				controller2.addEventListener( 'selectstart', onTeletransportLocomotionStart );
				controller2.addEventListener( 'selectend', onTeletransportLocomotionEnd );
				cameraHolder.add( controller2 );
				
				const controllerModelFactory = new XRControllerModelFactory();
				
				controllerGrip1 = renderer.xr.getControllerGrip(0);
				controllerGrip1.add( controllerModelFactory.createControllerModel( controllerGrip1 ) );
				cameraHolder.add( controllerGrip1 );
				
				controllerGrip2 = renderer.xr.getControllerGrip(1);
				controllerGrip2.add( controllerModelFactory.createControllerModel( controllerGrip2 ) );
				cameraHolder.add( controllerGrip2 );

				// VR Intersection
				const geometry = new THREE.BufferGeometry().setFromPoints( [ new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, -1 ) ] );
				const line = new THREE.Line( geometry );
				line.name = 'line';
				line.scale.z = 5;
				controller1.add( line.clone() );
				controller2.add( line.clone() );								
				raycaster = new THREE.Raycaster();
				
				// VR Locomotion
				// VR Locomotion - The guideline				
				const lineGeometry = new THREE.BufferGeometry();
				lineGeometryVertices = new Float32Array((lineSegments + 1) * 3);
				lineGeometryVertices.fill(0);
				const lineGeometryColors = new Float32Array((lineSegments + 1) * 3);
				lineGeometryColors.fill(0.5);
				lineGeometry.setAttribute('position', new THREE.BufferAttribute(lineGeometryVertices, 3));
				lineGeometry.setAttribute('color', new THREE.BufferAttribute(lineGeometryColors, 3));
				const lineMaterial = new THREE.LineBasicMaterial({ vertexColors: true, blending: THREE.AdditiveBlending });
				guideline = new THREE.Line( lineGeometry, lineMaterial );
				// VR Locomotion - The light at the end of the line
				guidelight = new THREE.PointLight(0x00ff00, 0, 2);				
				// VR Locomotion - The target on the ground
				const guidespriteTexture = loaderTexture.load('./models/target.png');
				guidesprite = new THREE.Mesh(
					new THREE.PlaneGeometry(1, 1, 1, 1),
					new THREE.MeshBasicMaterial({
						map: guidespriteTexture,
						blending: THREE.AdditiveBlending,
						color: 0x001100,
						transparent: true
					})
				);
				guidesprite.rotation.x = -Math.PI/2;				
												
				// Material Stuff
				let pmremGenerator = new THREE.PMREMGenerator( renderer );
				pmremGenerator.compileEquirectangularShader();				

				// Controls
				switch (_controlsType)
				{
					case "map":
						// Controls Map
						controls = new MapControls( camera, renderer.domElement );
						controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
						controls.dampingFactor = 0.05;
						controls.screenSpacePanning = true;
						controls.enableKeys = true;
						controls.keyPanSpeed = 12.0;
						controls.target.set(0,25,0);
						break;				
					case "orbit":
						// Controls Orbit
						controls = new OrbitControls( camera, renderer.domElement );
						controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
						controls.dampingFactor = 0.05;
						controls.screenSpacePanning = true;
						controls.enableKeys = true;
						controls.keyPanSpeed = 12.0;
						controls.target.set(0,25,0);
						break;
					case "fpv":
						// Controls First Person
						controls = new FirstPersonControls( cameraHolder, renderer.domElement );
						controls.activeLook = true;
						controls.autoForward = false;
						controls.movementSpeed = 10;
						controls.lookSpeed = 0.01;
						controls.lookVertical = true;
						camera.position.set( -11, 1, 1 );
						break;
					case "fly":
						// Controls Fly
						controls = new FlyControls( cameraHolder, renderer.domElement );
						controls.autoForward = false;
						controls.movementSpeed = 10;
						camera.position.set( -11, 1, 1 );
						break;
				}
				
				// Keyboard
				document.addEventListener("keydown", onDocumentKeyDown, false);
				// Mouse
				document.addEventListener('pointerdown', onDocumentMouseDown, false);
				document.addEventListener('touchstart', onDocumentTouchStart, false);
				document.addEventListener('touchmove', onDocumentTouchMove, false);							
				// Window
				window.addEventListener( 'resize', onWindowResize, false );

				// Stats
				if (_debugStats)
				{
					stats = new Stats();
					container.appendChild( stats.dom );
					statsVisibility = true;
				}
				
				// StatsVR
				if (_debugStats)
				{
					statsVR = new StatsVR(scene, camera);
					statsVR.setX(0);
					statsVR.setY(0);
					statsVR.setZ(-2);
					statsVR.setEnabled(false);
					statsVRVisibility = false;
				}
			}

			function onWindowResize() {
				SCREEN_WIDTH = window.innerWidth;
				SCREEN_HEIGHT = window.innerHeight;
				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;				
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				if (currentCamera!=null)
				{
					currentCamera.aspect = window.innerWidth / window.innerHeight;
					currentCamera.updateProjectionMatrix();
				}
				if (typeof controls.handleResize === 'function')
					controls.handleResize();
				renderer.setSize( window.innerWidth, window.innerHeight );				
			}

			function onTransitionStart( event ) {
				// Hide help initially?
				if (_hideHelpInitially)
				{
					closeHelpScreen();					
				}
				else
				{
					showHelpScreen();
				}
				// Shadows Off initially?
				if (_shadowsOffInitially)
				{
					dirLight.castShadow = false;
					renderer.shadowMap.enabled = false;
					renderer.shadowMap.autoUpdate = false;
					renderer.shadowMap.needsUpdate = true;						
				}				
			}
			
			function onTransitionEnd( event ) {
				debugLog( 'Remove loading screen' );
				const element = event.target;
				element.remove();	
				
				// Hide help after timeout
				if (!_hideHelpInitially)
				{
					setTimeout(closeHelpScreen, 10000);
				}
				
				// Add ENTER VR button
				document.body.appendChild( VRButton.createButton( renderer ) );				
			}
			
			function rotation2String(vec) {
				return "X: " + THREE.MathUtils.radToDeg(vec.x) + " Y: " + THREE.MathUtils.radToDeg(vec.y) + " Z: " + THREE.MathUtils.radToDeg(vec.z);
			}
			
			function debugLog( text ) {
				if (_debugLog)
					console.log( text );
			}
						
			function onDocumentKeyDown(event) {				
				if ( objStarShip == null ) return;
				var key = event.key;
				debugLog( 'KeyDown event: ' + key );
												
				switch (key) 
				{
					case 'h':
					case 'H':
						const helpScreen = document.getElementById( 'help' );
						if (helpScreen.style.visibility != "hidden")
							helpScreen.style.visibility = "hidden";
						else
							helpScreen.style.visibility = "visible";
						debugLog( 'Toggle help to ' + helpScreen.style.visibility);
						break;

					case 'e':
						if (stats != null)
						{	
							statsVisibility = !statsVisibility;
							if (statsVisibility)					
								container.appendChild( stats.dom );
							else
								container.removeChild( stats.dom );														
							debugLog( 'Toggle stats to ' + statsVisibility );
						}
						break;
					case 'E':
						if (statsVR != null)
						{	
							statsVRVisibility = !statsVRVisibility;						
							statsVR.setEnabled(statsVRVisibility && renderer.xr.isPresenting);
							debugLog( 'Toggle stats VR to ' + statsVRVisibility);
						}						
						break;
				
					case 'R':
						debugLog( 'Reset Wings rotation' );
						resetWingsRotation();
						break;
					case 'r':
						debugLog( 'Reset Last Wing rotation' );
						resetWingRotation(lastWingRotated);
						break;
					case 'M':
						debugLog( 'Wing rotation increased' );
						multiplierWingRotation = 5;
						break;
					case 'm':
						debugLog( 'Wing rotation decreased' );
						multiplierWingRotation = 1;
						break;
						
					case 'S':
						debugLog( 'Reset Engines rotation' );
						resetEngineRotation("1", objMotor1, defaultEngineRotation1, '');
						resetEngineRotation("2", objMotor2, defaultEngineRotation2, '');
						resetEngineRotation("3", objMotor3, defaultEngineRotation3, '');
						break;
					case 's':
						debugLog( 'Reset Last Engine rotation' );
						if (lastEngineRotated != null)
						{	
							resetEngineRotation("Last Rotated", lastEngineRotated, lastEngineRotatedDefaultRotation, lastEngineRotatedAxis);
						}
						break;
						
					case '1':
						if (event.keyCode >= 96)
						{
							rotateEngine("1", objMotor1, defaultEngineRotation1, incrementEngineRotation, event.ctrlKey, -10, +10, 'X');
						}
						else 
						{
							rotateWing("Top-Left", objTopLeftWing, incrementWingRotation * multiplierWingRotation, event.ctrlKey, 0, 72, +1);
						}
						break;
					case '2':
						if (event.keyCode >= 96)
						{
							resetEngineRotation("1", objMotor1, defaultEngineRotation1, '');
						}
						else
						{
							rotateWing("Top-Right", objTopRightWing, incrementWingRotation * multiplierWingRotation, event.ctrlKey, 0, -72, -1);
						}
						break;
					case '3':
						if (event.keyCode >= 96)
						{
							rotateEngine("1", objMotor1, defaultEngineRotation1, incrementEngineRotation, event.ctrlKey, -10, +10, 'Z');
						}
						else 
						{
							rotateWing("Bottom-Left", objBottomLeftWing, incrementWingRotation * multiplierWingRotation, event.ctrlKey, 0, 75, +1);
						}
						break;
					case '4':
						if (event.keyCode >= 96)
						{
							rotateEngine("2", objMotor2, defaultEngineRotation2, incrementEngineRotation, event.ctrlKey, -10, +10, 'X');
						}
						else 
						{
							rotateWing("Bottom-Right", objBottomRightWing, incrementWingRotation * multiplierWingRotation, event.ctrlKey, 0, -75, -1);
						}
						break;					
					case '5':
						if (event.keyCode >= 96)
						{
							resetEngineRotation("2", objMotor2, defaultEngineRotation2, '');
						}
						else 
						{
							rotateWing("Top-Left", objTopLeftWing, incrementWingRotation * multiplierWingRotation, event.ctrlKey, 0, 72, +1);
							rotateWing("Top-Right", objTopRightWing, incrementWingRotation * multiplierWingRotation, event.ctrlKey, 0, -72, -1);
						}
						break;
					case '6':
						if (event.keyCode >= 96)
						{
							rotateEngine("2", objMotor2, defaultEngineRotation2, incrementEngineRotation, event.ctrlKey, -10, +10, 'Z');
						}
						else 
						{
							rotateWing("Bottom-Left", objBottomLeftWing, incrementWingRotation * multiplierWingRotation, event.ctrlKey, 0, 75, +1);
							rotateWing("Bottom-Right", objBottomRightWing, incrementWingRotation * multiplierWingRotation, event.ctrlKey, 0, -75, -1);
						}
						break;
					case '7':
						if (event.keyCode >= 96)
						{
							rotateEngine("3", objMotor3, defaultEngineRotation3, incrementEngineRotation, event.ctrlKey, -10, +10, 'X');
						}
						else 
						{
							rotateWing("Top-Left", objTopLeftWing, incrementWingRotation * multiplierWingRotation, event.ctrlKey, 0, 72, +1);
							rotateWing("Top-Right", objTopRightWing, incrementWingRotation * multiplierWingRotation, event.ctrlKey, 0, -72, -1);
							rotateWing("Bottom-Left", objBottomLeftWing, incrementWingRotation * multiplierWingRotation, event.ctrlKey, 0, 75, +1);
							rotateWing("Bottom-Right", objBottomRightWing, incrementWingRotation * multiplierWingRotation, event.ctrlKey, 0, -75, -1);
						}
						break;
					case '8':
						if (event.keyCode >= 96)
						{
							resetEngineRotation("3", objMotor3, defaultEngineRotation3, '');
						}
						else
						{
							resetWingsRotation();
							rotateWing("Top-Left", objTopLeftWing, THREE.MathUtils.degToRad(40), false, 0, 72, +1);
							rotateWing("Top-Right", objTopRightWing, THREE.MathUtils.degToRad(40), false, 0, -72, -1);
							rotateWing("Bottom-Left", objBottomLeftWing, THREE.MathUtils.degToRad(40), false, 0, 75, +1);
							rotateWing("Bottom-Right", objBottomRightWing, THREE.MathUtils.degToRad(40), false, 0, -75, -1);
						}
						break;
					case '9':
						if (event.keyCode >= 96)
						{
							rotateEngine("3", objMotor3, defaultEngineRotation3, incrementEngineRotation, event.ctrlKey, -10, +10, 'Z');
						}
						else 
						{
							resetWingsRotation();
							rotateWing("Top-Left", objTopLeftWing, THREE.MathUtils.degToRad(90), false, 0, 72, +1);
							rotateWing("Top-Right", objTopRightWing, THREE.MathUtils.degToRad(90), false, 0, -72, -1);
							rotateWing("Bottom-Left", objBottomLeftWing, THREE.MathUtils.degToRad(90), false, 0, 75, +1);
							rotateWing("Bottom-Right", objBottomRightWing, THREE.MathUtils.degToRad(90), false, 0, -75, -1);
						}
						break;
					case '0':
						debugLog( 'Open all Wings' );
						resetWingsRotation();
						break;

					case 'C':
						debugLog( 'StarShip reset to launch position' );
						objStarShip.position.y = 0;
						break;					
					case 'c':
						debugLog( 'StarShip reset to land position' );
						objStarShip.position.y = 1;
						break;					
					case 'ArrowUp':
						if (event.ctrlKey)
						{
							debugLog( 'StarShip Move Forward' );
							objStarShip.position.z-=1;
						}
						else
						{
							debugLog( 'StarShip Up' );
							objStarShip.position.y+=1;
						}
						break;
					case 'ArrowDown':
						if (event.ctrlKey)
						{
							debugLog( 'StarShip Move Backward' );
							objStarShip.position.z+=1;
						}
						else
						{
							debugLog( 'StarShip Down' );
							if (objStarShip.position.y>0)
								objStarShip.position.y-=1;
						}
						break;
					case 'ArrowLeft':
						if (event.ctrlKey)
						{
							debugLog( 'StarShip Move Left' );
							objStarShip.position.x-=1;
						}
						else
						{
							debugLog( 'StarShip Rotate Left' );
							objStarShip.rotation.y+=0.01;
						}
						break;
					case 'ArrowRight':
						if (event.ctrlKey)
						{
							debugLog( 'StarShip Move Right' );
							objStarShip.position.x+=1;
						}
						else
						{
							debugLog( 'StarShip Rotate Right' );
							objStarShip.rotation.y-=0.01;							
						}
						break;

					case 'f':
						debugLog( 'StarShip shutdown engines' );
						if (particlesELight!=null)
							particlesELight.intensity = 0;
						if (particlesE1!=null)
							particlesE1.setAddParticles(false);
						if (particlesE2!=null)
							particlesE2.setAddParticles(false);
						if (particlesE3!=null)
							particlesE3.setAddParticles(false);
						break;						
					case 'F':
						debugLog( 'StarShip fire engines' );
						if (particlesELight!=null)
							particlesELight.intensity = 1;
						if (particlesE1!=null)
							particlesE1.setAddParticles(true);
						if (particlesE2!=nuhll)
							particlesE2.setAddParticles(true);
						if (particlesE3!=null)
							particlesE3.setAddParticles(true);
						break;						

					case 'F1':						
						if (event.ctrlKey)
							toggleEngineParticlesOnOff("1", particlesE1);
						break;						
					case 'F2':						
						if (event.ctrlKey)
							toggleEngineParticlesOnOff("2", particlesE2);
						break;						
					case 'F3':						
						if (event.ctrlKey)
							toggleEngineParticlesOnOff("3", particlesE3);
						break;						
						
					case 'g':
						debugLog( 'StarShip on ground' );
						sunLight.visible = true;
						spaceLight.visible = false;
						dirLight.color = new THREE.Color( 0xd4cec0 );
						scene.background = new THREE.Color( 0xd4cec0 );
						scene.fog = new THREE.Fog( 0xd4cec0, 50, 250 );
						plane.visible = true;
						scene.background = textureCube;
						applyEnvironmentMapToStarShip(envMap.texture, 0.45);
						break;
					case 'G':
						debugLog( 'StarShip on space' );
						sunLight.visible = false;
						spaceLight.visible = true;
						dirLight.color = new THREE.Color( 0xffffff );
						scene.background = new THREE.Color( 0x0 );
						scene.fog = new THREE.Fog( 0x0, 50, 2500 );
						plane.visible = false;
						scene.background = textureCube2;
						applyEnvironmentMapToStarShip(textureCube2, 1);
						break;
						
					case 'o':
						debugLog( 'Shadows off' );
						dirLight.castShadow = false;
						renderer.shadowMap.enabled = false;
						renderer.shadowMap.autoUpdate = false;
						renderer.shadowMap.needsUpdate = true;						
						break;
					case 'O':
						debugLog( 'Shadows on' );
						dirLight.castShadow = true;
						renderer.shadowMap.autoUpdate = true;
						renderer.shadowMap.enabled = true;
						break;
						
					case 'v':			
						if (camerasFixedArray!=null)
						{							
							currentCamera = camerasFixedArray[cameraFixedIndex];
							debugLog( 'Switching to fixed camera (' + cameraFixedIndex+ ') ' + currentCamera.name);
							currentCamera.aspect = window.innerWidth / window.innerHeight;
							currentCamera.updateProjectionMatrix();							
							cameraFixedIndex++;
							cameraFixedIndex%=camerasFixedArray.length;
						}
						break;
					case 'V':
						debugLog( 'Default camera restored' );
						currentCamera = null;
						break;
						
					// Information of renderer
					case 'i':
						console.log( "Scene render.calls: " + renderer.info.render.calls );
						console.log( "Scene render.triangles: " + renderer.info.render.triangles );
						console.log( "Scene render.points: " + renderer.info.render.points );
						console.log( "Scene render.lines: " + renderer.info.render.lines );
						console.log( "Scene render.frame: " + renderer.info.render.frame );
						console.log( "Scene geometries: " + renderer.info.memory.geometries );
						console.log( "Scene textures: " + renderer.info.memory.textures );
						break;
					case 'J':
						if (HumanMesh!=null)
							HumanMesh.visible = true;
						if (CubeMesh!=null)
							CubeMesh.visible = true;
						break;
					case 'j':
						if (HumanMesh!=null)
							HumanMesh.visible = false;
						if (CubeMesh!=null)
							CubeMesh.visible = false;
						break;
					case 'D':
						if (DragonMesh!=null)
							DragonMesh.visible = true;
						break;
					case 'd':
						if (DragonMesh!=null)
							DragonMesh.visible = false;
						break;
				} 
			}					
						
			function animate()
			{
				renderer.setAnimationLoop( function () {
					const delta = clock.getDelta();
					
					controls.update(delta);	
					updateIntersections();
					updateParticles( delta );
					updateLocomotion();
					updateStats();
					updateHelp();
					render(delta);	
				} );
			}

			function render( delta ) {												
				if (statsVR != null)
					statsVR.startTimer();
								
				if (currentCamera != null)
				{
					renderer.render( scene, currentCamera );
				}
				else 
				{
					renderer.render( scene, camera );
				}
				
				if (statsVR != null)
					statsVR.endTimer();					
				
				if (_debugShadow)
					lightShadowMapViewer.render( renderer );
			}

			function updateStats() {
				if (stats != null)
				{
					stats.update();
				}
				if (statsVR != null)
				{
					if (renderer.xr.isPresenting)
					{
						statsVR.setEnabled(statsVRVisibility);
						statsVR.update();
					}
					else 
					{
						statsVR.setEnabled(false);
					}
				}
			}
			
			function updateHelp() {
				if (renderer.xr.isPresenting)
					closeHelpScreen();
			}

			function updateParticles( delta ) {
				delta = delta;
				if (particlesE1!=null)
					particlesE1.step(delta);
				if (particlesE2!=null)
					particlesE2.step(delta);
				if (particlesE3!=null)
					particlesE3.step(delta);
					
				if (particlesELight!=null)				
					if (particlesELight.intensity!=0)
						particlesELight.intensity = 0.25 + Math.random();
			}

			function generateEnginesParticleSystem( object ) {
				debugLog("Generate Engines ParticleSystem");
				scene.updateMatrixWorld(true);
				var position = new THREE.Vector3();
				var rotation = new THREE.Vector3();
				// Particles - E1				
				objMotor1.getWorldPosition(position);
				objMotor1.getWorldDirection(rotation);				
				defaultEngineRotation1 = objMotor1.rotation.clone();
				debugLog("Engine001 World Position: "+position.x+" "+position.y+" "+position.z);						
				debugLog("Engine001 World Rotation: "+rotation2String(rotation));
				debugLog("Engine001 Local Rotation: "+rotation2String(defaultEngineRotation1));
				var orientation = new THREE.Group();
				orientation.scale.set(0,5,0);
				orientation.position.set(0, -22, 0);
				objMotor1.add(orientation);
				particlesE1 = new ParticleSystem({ parent: orientation, camera: camera });											
				objMotor1.userData.CurrentRotationX = 0;
				objMotor1.userData.CurrentRotationY = 0;
				objMotor1.userData.CurrentRotationZ = 0;
				
				// Particles - E2
				objMotor2.getWorldPosition(position);
				objMotor2.getWorldDirection(rotation);
				defaultEngineRotation2 = objMotor2.rotation.clone();
				debugLog("Engine002 World Position: "+position.x+" "+position.y+" "+position.z);
				debugLog("Engine002 World Rotation: "+rotation2String(rotation));
				debugLog("Engine002 Local Rotation: "+rotation2String(defaultEngineRotation2));
				var orientation = new THREE.Group();																																																
				orientation.scale.set(0,5,0);
				orientation.position.set(0, -22, 0);
				objMotor2.add(orientation);
				particlesE2 = new ParticleSystem({ parent: orientation, camera: camera });												
				objMotor2.userData.CurrentRotationX = 0;
				objMotor2.userData.CurrentRotationY = 0;
				objMotor2.userData.CurrentRotationZ = 0;
				
				// Particles - E3
				objMotor3.getWorldPosition(position);
				objMotor3.getWorldDirection(rotation);
				defaultEngineRotation3 = objMotor3.rotation.clone();
				debugLog("Engine003 World Position: "+position.x+" "+position.y+" "+position.z);
				debugLog("Engine003 World Rotation: "+rotation2String(rotation));
				debugLog("Engine003 Local Rotation: "+rotation2String(defaultEngineRotation3));
				var orientation = new THREE.Group();																																												
				orientation.scale.set(0,5,0);
				orientation.position.set(0, -22, 0);
				objMotor3.add(orientation);
				particlesE3 = new ParticleSystem({ parent: orientation, camera: camera });												
				objMotor3.userData.CurrentRotationX = 0;
				objMotor3.userData.CurrentRotationY = 0;
				objMotor3.userData.CurrentRotationZ = 0;
				
				// Light
				particlesELight = new THREE.PointLight(0xff0000, 0, 32);				
				particlesELight.position.set(0,1,0);				
				particlesELight.intensity = 1;
				object.add(particlesELight);
			}

			function toggleEngineParticlesOnOff(id, particles) {			
				debugLog( 'StarShip toggle Engine' + id);
				if (particles!=null)
				{
					particles.setAddParticles(!particles.getAddParticles());									
					if (particlesELight!=null)
					{
						var anyON = particlesE1.getAddParticles() || particlesE3.getAddParticles() || particlesE3.getAddParticles();
						particlesELight.intensity = (anyON)?1:0;
					}
				}
			}
			
			function resetEngineRotation(id, mesh, defaultEngineRotation, axis) {
				if (mesh != null)
				{
					switch (axis)
					{
						case 'X':
							mesh.rotate.x = defaultEngineRotation.x;
							mesh.userData.CurrentRotationX = 0;
							break;
						case 'Y':
							mesh.rotation.y = defaultEngineRotation.y;
							mesh.userData.CurrentRotationY = 0;
							break;
						case 'Z':
							mesh.rotation.z = defaultEngineRotation.z;
							mesh.userData.CurrentRotationZ = 0;
							break;
						default:
							mesh.rotation.x = defaultEngineRotation.x;
							mesh.rotation.y = defaultEngineRotation.y;
							mesh.rotation.z = defaultEngineRotation.z;
							mesh.userData.CurrentRotationX = 0;
							mesh.userData.CurrentRotationY = 0;
							mesh.userData.CurrentRotationZ = 0;
							break;
					}								
					lastEngineRotated = null;
					lastEngineRotatedAxis = '';
					lastEngineRotatedDefaultRotation = null;
					debugLog( "Reset rotation Engine " + id + ' on axis ' + axis);				
					debugLog( "Engine Local Rotation: "+rotation2String(defaultEngineRotation));
				}
			};
			
			function rotateEngine(id, mesh, defaultEngineRotation, increment, reverse, minAngle, maxAngle, axis) {
				if (reverse)
					increment = -increment;					
				var radAngle;
				switch (axis)
				{
					case 'X':
						radAngle = mesh.userData.CurrentRotationX;
						break;
					case 'Y':
						radAngle = mesh.userData.CurrentRotationY;
						break;
					case 'Z':
						radAngle = mesh.userData.CurrentRotationZ;
						break;
				}								
				var finalAngle = THREE.MathUtils.radToDeg(radAngle + increment);
				if (finalAngle < minAngle) 
					finalAngle = minAngle;
				if (finalAngle > maxAngle) 
					finalAngle = maxAngle;				
				radAngle = THREE.MathUtils.degToRad(finalAngle);
				switch (axis)
				{
					case 'X':
						mesh.rotation.x = defaultEngineRotation.x + radAngle;
						mesh.userData.CurrentRotationX = radAngle;
						break;
					case 'Y':
						mesh.rotation.y = defaultEngineRotation.y + radAngle;
						mesh.userData.CurrentRotationY = radAngle;
						break;
					case 'Z':
						mesh.rotation.z = defaultEngineRotation.z + radAngle;
						mesh.userData.CurrentRotationZ = radAngle;
						break;
				}				
				lastEngineRotated = mesh;
				lastEngineRotatedAxis = axis;
				lastEngineRotatedDefaultRotation = defaultEngineRotation;
				debugLog( id + ' Engine rotation on ' + axis + ' axis to ' + finalAngle + ' degrees');
			}

			function adaptWingObject(wing) {			
				if (_debugShowWingsAxis)
				{
					const axesHelper = new THREE.AxesHelper( 50 );
					wing.add( axesHelper );											
					wing.material.transparent = true;
					wing.material.opacity = 0.5;
				}
				wing.userData.CurrentRotation = 0;
			}

			function resetWingsRotation() {			
				objTopLeftWing.rotateY(-objTopLeftWing.userData.CurrentRotation); 
				objTopLeftWing.userData.CurrentRotation = 0;
				objTopRightWing.rotateY(-objTopRightWing.userData.CurrentRotation); 
				objTopRightWing.userData.CurrentRotation = 0;
				objBottomLeftWing.rotateY(-objBottomLeftWing.userData.CurrentRotation); 
				objBottomLeftWing.userData.CurrentRotation = 0;
				objBottomRightWing.rotateY(-objBottomRightWing.userData.CurrentRotation); 
				objBottomRightWing.userData.CurrentRotation = 0;
			}
			
			function resetWingRotation(wing) {
				if (wing != null)
				{
					wing.rotateY(-wing.userData.CurrentRotation); 
					wing.userData.CurrentRotation = 0;
				}
			}
			
			function rotateWing(id, mesh, increment, reverse, minAngle, maxAngle, dir) {
				if (reverse)
					increment = -increment;						
				var finalIncrement = dir * increment;
				var angle = THREE.MathUtils.radToDeg(mesh.userData.CurrentRotation + finalIncrement);
				var finalAngle = angle;
				if (dir > 0)
				{
					if (finalAngle < minAngle) 
						finalAngle = minAngle;
					if (finalAngle > maxAngle) 
						finalAngle = maxAngle;
				}
				else
				{
					if (finalAngle > minAngle) 
						finalAngle = minAngle;
					if (finalAngle < maxAngle) 
						finalAngle = maxAngle;
				}
				finalIncrement -= THREE.MathUtils.degToRad(angle-finalAngle);	
				mesh.userData.CurrentRotation += finalIncrement;
				mesh.rotateY(finalIncrement);
				lastWingRotated = mesh;
				debugLog( id + ' Wing rotation to ' + THREE.MathUtils.radToDeg(mesh.userData.CurrentRotation) + ' degrees');
			}

			function applyEnvironmentMapToStarShip( texture, intensity ) {
				if (objStarShip == null) return;
				debugLog("Setting environment map to StarShip material");
				objStarShip.traverse(function(child) {
					if (child instanceof THREE.Mesh) {
						if ( intensity > 0 )
							child.material.envMapIntensity = intensity;
						child.material.envMap = texture;
						child.material.needsUpdate = true;
					}
				} );
			}
						
			function updateLocomotion() {
				if (guidingController) 
				{
					// Controller start position
					const p = guidingController.getWorldPosition(tempVecP);

					// Set Vector V to the direction of the controller, at 1m/s
					const v = guidingController.getWorldDirection(tempVecV);

					// Scale the initial velocity to 6m/s
					v.multiplyScalar(6);

					// Time for tele ball to hit ground
					const t = (-v.y  + Math.sqrt(v.y**2 - 2*p.y*g.y))/g.y;

					const vertex = tempVec.set(0,0,0);
					for (let i=1; i<=lineSegments; i++) {

						// set vertex to current position of the virtual ball at time t
						positionAtT(vertex,i*t/lineSegments,p,v,g);
						guidingController.worldToLocal(vertex);
						vertex.toArray(lineGeometryVertices,i*3);
					}
					guideline.geometry.attributes.position.needsUpdate = true;
					
					// Place the light and sprite near the end of the poing
					positionAtT(guidelight.position,t*0.98,p,v,g);
					positionAtT(guidesprite.position,t*0.98,p,v,g);
				}
			}
			
			function onTeletransportLocomotionStart( event ) {
				guidingController = event.target;
				guidelight.intensity = 1;
				guidingController.add(guideline);
				scene.add(guidelight);
				scene.add(guidesprite);
			}

			function onTeletransportLocomotionEnd( event ) {
				if (guidingController === event.target) 
				{
					// first work out vector from feet to cursor
					// feet position
					const feetPos = renderer.xr.getCamera(camera).getWorldPosition(tempVec);
					feetPos.y = 0;
					// cursor position
					const p = guidingController.getWorldPosition(tempVecP);
					const v = guidingController.getWorldDirection(tempVecV);
					v.multiplyScalar(6);
					const t = (-v.y  + Math.sqrt(v.y**2 - 2*p.y*g.y))/g.y;
					const cursorPos = positionAtT(tempVec1,t,p,v,g);
					// offset
					const offset = cursorPos.addScaledVector(feetPos ,-1);
					// do the locomotion
					locomotion(offset);
					// clean up
					guidingController = null;
					guidelight.intensity = 0;
					event.target.remove(guideline);
					scene.remove(guidelight);
					scene.remove(guidesprite);
				}
			}
			
			function locomotion(offset) {
				cameraHolder.position.add(offset);
			} 
			
			function positionAtT(inVec,t,p,v,g) {
				inVec.copy(p);
				inVec.addScaledVector(v,t);
				inVec.addScaledVector(g,0.5*t**2);
				return inVec;
			}
			
			function updateIntersections() {
				cleanIntersected();
				intersectObjects( controller1 );
				intersectObjects( controller2 );							
				checkMouseIntersect();
			}
			
			let mouseVectors = new THREE.Vector2();
			let targetRotationX = 0;
			let targetRotationY = 1;
			let targetRotationXOnMouseDown = 0;
			let targetRotationYOnMouseDown = 0;
			let mouseX = 0;
			let mouseXOnMouseDown = 0;
			let mouseY = 0;
			let mouseYOnMouseDown = 0;
			
			function checkMouseIntersect() {
				if (mouseRaycasterCheck) {
					debugLog("Check if Mouse intersects something...");
					mouseRaycaster.setFromCamera(mouseVectors, camera);

					var intersected = mouseRaycaster.intersectObjects(mouseIntersectableObjects, true);
					if (intersected.length > 0) {
						checkMouseHit(intersected);
					}					
				}				
			}
			
			function checkMouseHit(intersections) {
				var i = 0,
				l = intersections.length;
				if (l > 0) {
					const intersection = intersections[0];
					const object = intersection.object;
					moveButton(object);
					executeButton(object);
					/* ToDo
					if (_soundsLoaded) {
						stopSound();
						playSound(soundButtonClickBuffer);
					}
					*/
				}
			}			
			
			let tweenButton = null;
			
			function moveButton(object) {
				if (tweenButton!=null)				
					if (tweenButton.isActive()) return;
				debugLog("Move Button " + object.name);								
				tweenButton = TweenMax.to(object.position, 0.05, {
					ease: Expo.easeInOut,
					y:object.position.y-0.1,
					yoyo: true,
					repeat: 1
				});
			}			
			
			function executeButton(object)
			{
				switch (object.name)
				{
					case "LeftTop_IncreaseButton": 
						rotateWing("Top-Left", objTopLeftWing, incrementWingRotation * multiplierWingRotation, false, 0, 72, +1);
						break;					
					case "LeftTop_DecreaseButton": 
						rotateWing("Top-Left", objTopLeftWing, incrementWingRotation * multiplierWingRotation, true, 0, 72, +1);
						break;
					case "LeftTop_ResetButton": 
						resetWingRotation(objTopLeftWing);
						break;

					case "RightTop_IncreaseButton": 
						rotateWing("Top-Right", objTopRightWing, incrementWingRotation * multiplierWingRotation, false, 0, -72, -1);
						break;					
					case "RightTop_DecreaseButton": 
						rotateWing("Top-Right", objTopRightWing, incrementWingRotation * multiplierWingRotation, true, 0, -72, -1);
						break;
					case "RightTop_ResetButton": 
						resetWingRotation(objTopRightWing);
						break;

					case "LeftBottom_IncreaseButton": 
						rotateWing("Bottom-Left", objBottomLeftWing, incrementWingRotation * multiplierWingRotation, false, 0, 75, +1);
						break;					
					case "LeftBottom_DecreaseButton": 
						rotateWing("Bottom-Left", objBottomLeftWing, incrementWingRotation * multiplierWingRotation, true, 0, 75, +1);
						break;
					case "LeftBottom_ResetButton": 
						resetWingRotation(objBottomLeftWing);
						break;

					case "RightBottom_IncreaseButton": 
						rotateWing("Bottom-Right", objBottomRightWing, incrementWingRotation * multiplierWingRotation, false, 0, -75, -1);
						break;					
					case "RightBottom_DecreaseButton": 
						rotateWing("Bottom-Right", objBottomRightWing, incrementWingRotation * multiplierWingRotation, true, 0, -75, -1);
						break;
					case "RightBottom_ResetButton": 
						resetWingRotation(objBottomRightWing);
						break;
				}
			}
			
			function simulateKeyEvent(character) {
			  var evt = document.createEvent("KeyboardEvent");
			  (evt.initKeyEvent || evt.initKeyboardEvent)("keypress", true, true, window,
								0, 0, 0, 0,
								0, character.charCodeAt(0)) 
			  var canceled = !body.dispatchEvent(evt);
			  if(canceled) {
				// A handler called preventDefault
				alert("canceled");
			  } else {
				// None of the handlers called preventDefault
				alert("not canceled");
			  }
			}			
						
			function onDocumentMouseDown(event) {
				debugLog("On MouseDown");
				
				event.preventDefault();
				document.addEventListener('mousemove', onDocumentMouseMove, false);
				document.addEventListener('pointerup', onDocumentMouseUp, false);
				document.addEventListener('mouseout', onDocumentMouseOut, false);
				mouseXOnMouseDown = event.clientX - windowHalfX;
				mouseYOnMouseDown = event.clientY - windowHalfY;
				targetRotationXOnMouseDown = targetRotationX;
				targetRotationYOnMouseDown = targetRotationY;
				mouseVectors.x = (event.clientX / window.innerWidth) * 2 - 1;
				mouseVectors.y = -(event.clientY / window.innerHeight) * 2 + 1;
				mouseRaycasterCheck = true;
			}

			function onDocumentMouseMove(event) {
				debugLog("On MouseMove");
				
				mouseX = event.clientX - windowHalfX;
				mouseY = event.clientY - windowHalfY;
				targetRotationX = targetRotationXOnMouseDown + (mouseX - mouseXOnMouseDown) * 0.02;
				targetRotationY = targetRotationYOnMouseDown + (mouseY - mouseYOnMouseDown) * 0.02;
			}

			function onDocumentMouseUp() {
				debugLog("On MouseUp");
				document.removeEventListener('mousemove', onDocumentMouseMove, false);
				document.removeEventListener('pointerup', onDocumentMouseUp, false);
				document.removeEventListener('mouseout', onDocumentMouseOut, false);
				mouseRaycasterCheck = false;
			}

			function onDocumentMouseOut() {
				debugLog("On MouseOut");
				document.removeEventListener('mousemove', onDocumentMouseMove, false);
				document.removeEventListener('pointerup', onDocumentMouseUp, false);
				document.removeEventListener('mouseout', onDocumentMouseOut, false);
			}

			function onDocumentTouchStart(event) {
				if (event.touches.length === 1) {
					event.preventDefault();
					mouseXOnMouseDown = event.touches[0].pageX - windowHalfX;
					mouseYOnMouseDown = event.touches[0].pageY - windowHalfY;
					targetRotationXOnMouseDown = targetRotationX;
					targetRotationYOnMouseDown = targetRotationY;
				}
			}

			function onDocumentTouchMove(event) {
				if (event.touches.length === 1) {
					event.preventDefault();
					mouseX = event.touches[0].pageX - windowHalfX;
					mouseY = event.touches[0].pageY - windowHalfY;
					targetRotationX = targetRotationXOnMouseDown + (mouseX - mouseXOnMouseDown) * 0.05;
					targetRotationY = targetRotationYOnMouseDown + (mouseY - mouseYOnMouseDown) * 0.05;
				}
			}
	
			/* // ToDo
			function loadSound(url) {
				var request = new XMLHttpRequest();

				request.open('GET', url, true);
				request.responseType = 'arraybuffer';

				request.onload = function () {
					audioContext.decodeAudioData(request.response, function (buffer) {
						alertBuffer = buffer;
						alertLoaded = true;
					});
				};

				request.send();
			}

			function stopSound() {
				if (audioSource) {
					audioSource.stop();
				}
			}

			function playSound(buffer) {
				audioSource = audioContext.createBufferSource();
				audioSource.buffer = buffer;
				audioSource.connect(audioContext.destination);
				audioSource.start(0);
			}
			
			let audioContext;
			let audioSource;
			
			window.AudioContext = window.AudioContext || window.webkitAudioContext;
			audioContext = new AudioContext();

			loadAlertSound('https://s3-us-west-2.amazonaws.com/s.cdpn.io/8223/alert.mp3');
			*/	
			
			function onGrabStart( event ) {
				const controller = event.target;
				if (guidingController === controller) 
				{
					// clean up locomotion if actived
					guidingController = null;
					guidelight.intensity = 0;
					controller.remove(guideline);
					scene.remove(guidesprite);
				}									
				const intersections = getIntersections( controller );
				if ( intersections.length > 0 ) {
					const intersection = intersections[ 0 ];
					const object = intersection.object;
					object.material.emissive.b = 1;
					intersectionParent = object.parent;
					controller.attach( object );
					controller.userData.selected = object;									
				}
			}

			function onGrabEnd( event ) {
				const controller = event.target;
				if ( controller.userData.selected !== undefined ) {
					const object = controller.userData.selected;
					object.material.emissive.b = 0;
					intersectionParent.attach( object );
					controller.userData.selected = undefined;
				}
			}

			function getIntersections( controller ) {
				tempMatrix.identity().extractRotation( controller.matrixWorld );
				raycaster.ray.origin.setFromMatrixPosition( controller.matrixWorld );
				raycaster.ray.direction.set( 0, 0, - 1 ).applyMatrix4( tempMatrix );
				return raycaster.intersectObjects( intersectableObjects );
			}

			function intersectObjects( controller ) {
				// Do not highlight when already selected
				if ( controller.userData.selected !== undefined ) return;
				const line = controller.getObjectByName( 'line' );
				const intersections = getIntersections( controller );
				if ( intersections.length > 0 ) {
					const intersection = intersections[ 0 ];
					const object = intersection.object;
					object.material.emissive.r = 1;
					intersected.push( object );
					line.scale.z = intersection.distance;
				} else {
					line.scale.z = 5;
				}
			}

			function cleanIntersected() {
				while ( intersected.length ) {
					const object = intersected.pop();
					object.material.emissive.r = 0;
				}
			}		
		
			main();
			
		</script>
	</body>
</html>